#! /usr/bin/env python3

import sys
import os
import re
import argparse

import uweclang


# Script global variables for setting the extension for output files.
_OUTPUT_EXTENSION = ''
_MEMO_OUTPUT_EXTENSION = ''
_LOG_OUTPUT_EXTENSION = ''


_CAPS_LIMIT = 100
_PUNC_LIMIT = 100


def scrub_plaintext(input_filename, output_dir, verbosity=1):
    """Batch processing function for removing unwanted data from plaintext
    files.

    Arguments:
        input_filename (str): The input file.
        output_dir (str): The directory of the ouput files.
        verbosity (int): The verbosity of the output.

    Returns:
        (None)

    Raises:
        (None): Will kill the program on IOErrors.
    """

    # Construct output filenames.
    global _OUTPUT_EXTENSION, _MEMO_OUTPUT_EXTENSION, _LOG_OUTPUT_EXTENSION

    output_filename = os.path.join(output_dir,
                                   os.path.splitext(os.path.basename(input_filename))[0]
                                   + _OUTPUT_EXTENSION)
    memo_filename = os.path.join(output_dir,
                                 os.path.splitext(os.path.basename(input_filename))[0]
                                 + _MEMO_OUTPUT_EXTENSION)
    log_filename = os.path.join(output_dir,
                                os.path.splitext(os.path.basename(input_filename))[0]
                                + _LOG_OUTPUT_EXTENSION)


    # Get document text and split into lines.
    try:
        lines = uweclang.line_split(open(input_filename, 'r').read())
    except IOError as e:
        print('Error openning file {}: {}'.format(input_filename, e))
        sys.exit(1)

    # Open output file.
    try:
        out = open(output_filename, 'w')
    except IOError as e:
        print('Error creating file {}: {}'.format(output_filename, e))
        sys.exit(1)


    # Open log file.
    try:
        log = open(log_filename, 'w')
    except IOError as e:
        print('Error creating file {}: {}'.format(log_filename, e))
        sys.exit(1)


    found_memo = False
    result = []
    memo = []
    for line_number, line in enumerate(lines):
        # Straighten quotes.
        line = uweclang.straighten_quotes(line)

        # Remove empty lines.
        if re.fullmatch(r'\s*', line):
            print('Line {}: REMOVE (Empty Line, {} characters):'
                  '\n\t{}\n'.format(line_number, len(line), line),
                  file=log)
            continue

        # Remove number lines.
        if re.fullmatch(r'\d+', line):
            print('Line {}: REMOVE (Number Line, {} characters):'
                  '\n\t{}\n'.format(line_number, len(line), line),
                  file=log)
            continue

        global _CAPS_LIMIT, _PUNC_LIMIT
        punc = uweclang.punctuation_density(line)
        caps = uweclang.capitalization_density(line)

        # Remove citations
        if punc > _PUNC_LIMIT:
            print('Line {}: REMOVE (Line Punctuation = {:.3f}):'
                  '\n\t{}\n'.format(line_number, caps, line),
                  file=log)
            continue

        # Remove titles
        if caps > _CAPS_LIMIT:
            if re.match('writer.*memo', line, flags=re.IGNORECASE):
                found_memo = True
                # Open memo file.
                try:
                    memo = open(memo_filename, 'w')
                except IOError as e:
                    print('Error creating file {}: {}'.format(memo_filename, e))
                    sys.exit(1)

            print('Line {}: REMOVE (Line Capitalization = {:.3f}):'
                  '\n\t{}\n'.format(line_number, caps, line),
                  file=log)
            continue

        # Inline citation detector:
        def citation_detector(text, is_parenthetical):
            global _CAPS_LIMIT, _PUNC_LIMIT

            if is_parenthetical:
                punc = uweclang.punctuation_density(text)
                caps = uweclang.capitalization_density(text)

                if punc > _PUNC_LIMIT:
                    print('Line {}: EDIT OUT '
                          '(Parenthetical Punctuation = {:.3f}):'
                          '\n\t({})\n'.format(line_number, punc, text),
                          file=log)
                    return False

                if caps > _CAPS_LIMIT:
                    print('Line {}: EDIT OUT '
                          '(Parenthetical Capitalization = {:.3f}):'
                          '\n\t({})\n'.format(line_number, caps, line),
                          file=log)
                    return False
            return True

        # Remove inline citations:
        pars = uweclang.seperate_parentheticals(line)
        line = uweclang.recombine_selected(citation_detector, pars)


        if found_memo:
            print(line, file=memo)
        else:
            print(line, file=out)


    if verbosity >= 1:
        print('Scrubbed text from '
              '{} into {}'.format(os.path.basename(input_filename),
                                  os.path.basename(output_filename)))


if __name__ == '__main__':

    # Create a command line argument parser based on the BATCH_PARSER template.
    # See uweclang/batch/tools.py for details.
    parser = argparse.ArgumentParser(
        description='Extracts plaintext from docx files',
        parents=[uweclang.BATCH_PARSER])


    # Add extra command line arguments for this script.
    parser.add_argument('-e', '--extensions',
                        nargs='*',
                        default=['.txt'],
                        metavar='ext',
                        dest='ext',
                        help='accepted file extensions for input')

    parser.add_argument('-x', '--o-extension',
                        nargs='?',
                        default='.txt',
                        metavar='oext',
                        dest='oext',
                        help='extension for output file')

    parser.add_argument('--l-extension',
                        nargs='?',
                        default='.log',
                        metavar='lext',
                        dest='lext',
                        help='extension for output log file')

    parser.add_argument('--m-extension',
                        nargs='?',
                        default='.memo',
                        metavar='mext',
                        dest='mext',
                        help='extension for output memo file')

    parser.add_argument('--caps-limit',
                        type=float,
                        default=0.06,
                        metavar='percent',
                        dest='caps',
                        help='capitalization percent for title removal')

    parser.add_argument('--punc-limit',
                        type=float,
                        default=0.05,
                        metavar='percent',
                        dest='punc',
                        help='punctuation percent for citation removal')

    # Parse command line arguments.
    args = parser.parse_args()


    # Set default verbosity.
    if args.verbose is None:
        args.verbose = 1

    _OUTPUT_EXTENSION = args.oext
    _MEMO_OUTPUT_EXTENSION = args.mext
    _LOG_OUTPUT_EXTENSION = args.lext
    _CAPS_LIMIT = args.caps
    _PUNC_LIMIT = args.punc

    # Setup extension checking function.
    def is_valid_target(file):
        return os.path.isfile(file) and os.path.splitext(file)[1] in args.ext


    # Select the files to process.
    (files, ignored_files) = uweclang.select_files(args,
                                                   file_selector=is_valid_target)


    # Resolve relative ouput path.
    out_path = os.path.abspath(args.output)


    # Print list of ignored files.
    if args.verbose >= 1:
        for x in ignored_files:
            print("Ignore file:", x)
        print('\n--- Begin Processing ---')


    # Process the files.
    if args.batch_mode == 'none':
        # Process each file seperately.
        for filename in files:
            name_part = os.path.splitext(os.path.basename(filename))[0]
            scrub_plaintext(filename,
                            out_path,
                            verbosity=args.verbose)
    else:
        # Process files in batch mode.
        uweclang.batch_process(scrub_plaintext,
                               in_files=list(files),
                               out_dir=out_path,
                               batch_size=args.batch_size,
                               batch_mode=args.batch_mode,
                               verbosity=args.verbose)

    if args.verbose >= 1:
        print('--- End Processing ---\n')
