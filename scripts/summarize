#! /usr/bin/env python

# Python 3 forward compatability imports.
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from __future__ import unicode_literals

# Standard imports
import sys
import os
import io
import re
import argparse

import uweclang
import nltk

from nltk.corpus import TaggedCorpusReader
from collections import Counter
from pprint import pprint


# We want to write all files in UTF-8 encoding. (This is a Python 3 forward
# compatability issue.)
reload(sys)
sys.setdefaultencoding('utf8')

_COLLECTED_DATA = dict()
_COLLECTED_MEMO_DATA = dict()


def collect_file(input_filename, output_dir, verbosity=1):
    """Batch processing function for tagging plaintext files.

    Arguments:
        input_filename (str): The input file.
        output_dir (str): The directory of the ouput files.
        verbosity (int): The verbosity of the output.

    Returns:
        (None)

    Raises:
        (None): Will kill the program on IOErrors.
    """
    # Get document text.
    try:
       with open(input_filename, 'r') as f:
           text = f.read().splitlines()
    except IOError as e:
        print('Error openning file {}: {}'.format(input_filename, e))
        sys.exit(1)


    # Prepare to read data from text.
    fmt_regex = re.compile(r'(\t)?(.*), ([^,]*), ([^,]*);')
    convert = {'int': int,
               'float': float,
               'str': (lambda x: x)}

    # Read text into dictionary.
    data = dict()
    last = None
    for line in text:
        match = fmt_regex.match(line)
        if match:
            # Strip groups
            m = (match.group(2).strip(),
                 match.group(3).strip(),
                 match.group(4).strip())

            if match.group(1) is None:
                data[m[0]] = convert[m[2]](m[1])
                last = m[0]
            else:
                if not isinstance(data[last], Counter):
                    data[last + ' (Total)'] = data[last]
                    data[last] = Counter()
                data[last][m[0]] += convert[m[2]](m[1])

    # Save dictionary into collected data:
    if uweclang.split_ext(input_filename)[1].startswith('.memo'):
        _COLLECTED_MEMO_DATA[input_filename] = data
    else:
        _COLLECTED_DATA[input_filename] = data

    # Print task completion.
    if verbosity >= 1:
        print('Read data for {}.'.format(os.path.basename(input_filename)))



if __name__ == '__main__':

    # Create a command line argument parser based on the BATCH_PARSER template.
    # See uweclang/batch/tools.py for details.
    parser = argparse.ArgumentParser(
        description='Summarizes result files',
        parents=[uweclang.BATCH_PARSER])

    # Parse command line arguments.
    args = parser.parse_args()

    # Set input extensions for files to read.
    args.extensions = args.extensions or ['.res.txt']

    # Set default verbosity.
    args.verbose = args.verbose or 1

    # Process the files.
    uweclang.batch_process(collect_file, **vars(args))


    # Aggregate data.
    if args.verbose >= 1:
        print('Aggregating...')

    summary = None
    for file_name, data in _COLLECTED_DATA.iteritems():
        # Initialize summary from first file.
        if summary is None:
            summary = data
            summary['Files'] = [summary.pop('File', None)]
            continue

        # Aggregate current file data into summary.
        summary['Files'].append(data['File'])
        for k, v in data.iteritems():
            if isinstance(v, str):
                continue
            elif isinstance(v, Counter):
                summary[k].update(v)
            else:
                summary[k] += v

        # Print CSV Data
        print(uweclang.analysis_to_row(data))

    # Correct averages for multiple files.
    for k, v in summary.iteritems():
        if isinstance(v, float):
            summary[k] /= len(summary['Files'])

    # Print short summary.
    if args.verbose >= 1:
        fmt = '{:25}{}'
        for k, v in summary.iteritems():
            if isinstance(v, list):
                print(fmt.format(k, len(v)))
            elif not isinstance(v, Counter):
                print(fmt.format(k, v))

    # Open output file.
    try:
        out = io.open(args.output_dir, 'w', newline='\r\n')
    except IOError as e:
        print('Error creating file {}: {}'.format(output_filename, e))
        sys.exit(1)

    # Write to output file.
    out.write(uweclang.analysis_to_str(summary))
    out.close()
